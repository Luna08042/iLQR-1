from pydrake.systems.framework import VectorSystem
import numpy as np
from numpy import sin, cos
from numpy import linalg as LA
from pydrake.forwarddiff import jacobian
'''
x = [q, q_dot]
q = [x,y,z, phi(roll), theta(pitch), psi(yaw)]
[x,y,z]: position of quadrotor CG in world frame.
[r, p, y]: 321 rotation (same as Drake's RollPitchYaw class and 
  the Mechanics of Flight textbook by Phillips)

Body frame and propeller numbering. Body z-axis points towards you. 

       1       0
        \  x  /
         \ | /   
      y___\|/  
          / \  
         /   \ 
        /     \
       2       3

Define constants kF and kM.
u[i]*kF (kM) is the force (torque) generated by propeller i.  
'''
kF = 1.0
kM = 0.0245
l = 0.175/np.sqrt(2.0) # (length of one arm) / sqrt(2)
n = 12 # 12 states
m = 4 # 4 inputs


def CalcRx(phi):
    c = cos(phi)
    s = sin(phi)
    Rx = np.array([[1., 0., 0.],
                   [0, c, -s],
                   [0, s, c]])
    return Rx


def CalcRy(theta):
    c = cos(theta)
    s = sin(theta)
    Ry = np.array([[c, 0., -s],
                   [0, 1., 0],
                   [s, 0., c]])
    return Ry


def CalcRz(psi):
    c = cos(psi)
    s = sin(psi)
    Rz = np.array([[c, -s, 0],
                   [s, c, 0],
                   [0., 0., 1]])
    return Rz


# Transformation matrix from Body frame to World frame.
def CalcR_WB(rpy):
    phi = rpy[0] # roll angle
    theta = rpy[1] # pitch angle
    psi = rpy[2] # yaw angle

    return CalcRz(psi).dot(CalcRy(theta).dot(CalcRx(phi)))


'''
pqr = Phi_inv * rpy_d
pqr is the angular velocity expressed in Body frame.
'''
def CalcPhiInv(rpy):
    roll = rpy[0]
    pitch = rpy[1]
    sr = sin(roll)
    cr = cos(roll)
    sp = sin(pitch)
    cp = cos(pitch)

    Phi = np.array([[1, 0, -sp],
                    [0, cr, sr*cp],
                    [0, -sr, cr*cp]])
    return Phi


'''
rpy_d = Phi * pqr
pqr is the angular velocity expressed in Body frame.
'''
def CalcPhi(rpy):
    roll = rpy[0]
    pitch = rpy[1]
    sr = sin(roll)
    cr = cos(roll)
    sp = sin(pitch)
    cp = cos(pitch)

    Phi = np.array([[1, sr*sp/cp, cr*sp/cp],
                    [0, cr, -sr],
                    [0, sr/cp, cr/cp]])
    return Phi


def CalcPhiD(rpy):
    roll = rpy[0]
    pitch = rpy[1]
    sr = sin(roll)
    cr = cos(roll)
    sp = sin(pitch)
    cp = cos(pitch)
    cp2 = cp**2
    tp = sp/cp

    Phi_D = np.empty((3,3,3), dtype=object)
    Phi_D[:,0,:] = 0.0
    Phi_D[0, 1] = [cr * tp, sr / cp2, 0]
    Phi_D[0, 2] = [-sr * tp, cr / cp2, 0]
    Phi_D[1, 1] = [-sr, 0, 0]
    Phi_D[1, 2] = [-cr, 0, 0]
    Phi_D[2, 1] = [cr/cp, sr*sp/cp2, 0]
    Phi_D[2, 2] = [-sr/cp, cr*sp/cp2, 0]

    return Phi_D


# Define the system.
class Quadrotor(VectorSystem):
    def __init__(self):
        VectorSystem.__init__(self,
            m,                           # No. of inputs.
            n)                           # No. of output.
        self._DeclareContinuousState(n)
        self.mass = 0.5
        self.I = np.array([[0.0023, 0, 0],
                      [0, 0.0023, 0],
                      [0, 0, 0.0040]])
        self.g = 10.

    # define dynamics in a separate function, so that it can be passed to
    # ForwardDiff.jacobian for derivatives.
    def f(self, x_u):
        x = x_u[0:n]
        u = x_u[n:n+m]
        xdot = np.empty(x.shape, dtype=object)

        I_inv = LA.inv(self.I)
        uF = kF * u
        uM = kM * u
        Fg = np.array([0., 0., -self.mass*self.g])
        F = np.array([0., 0., uF.sum()])
        M = np.array([l*(-uF[0] - uF[1] + uF[2] + uF[3]),
                      l*(-uF[0] - uF[3] + uF[1] + uF[2]),
                      - uM[0] + uM[1] - uM[2] + uM[3]])

        rpy = x[3:6]
        rpy_d = x[9:12]
        R_WB = CalcR_WB(rpy)

        # translational acceleration in world frame
        xyz_dd = 1./self.mass*(R_WB.dot(F) + Fg)

        # pqr: angular velocity in body frame
        Phi_inv = CalcPhiInv(rpy)
        pqr = Phi_inv.dot(rpy_d)
        pqr_d = I_inv.dot(M - np.cross(pqr, self.I.dot(pqr)))

        '''
        rpy_d = Phi * pqr ==>
        rpy_dd = Phi_d * pqr + 
        Phi_d.size = (3,3,3): Phi_d[i,j] is the partial of Phi[i,j]
            w.r.t rpy. 
        '''
        Phi_d = CalcPhiD(rpy)
        Phi = CalcPhi(rpy)
        rpy_dd = Phi.dot(pqr_d) + (Phi_d.dot(rpy_d)).dot(pqr)

        xdot[0:6] = x[6:12]
        xdot[6:9] = xyz_dd
        xdot[9:12] = rpy_dd
        return xdot

    # xdot(t) = -x(t) + x^3(t)
    def _DoCalcVectorTimeDerivatives(self, context, u, x, xdot):
        x_u = np.hstack((x.flatten(), u.flatten()))
        xdot[:] = self.f(x_u)

    # y(t) = x(t)
    def _DoCalcVectorOutput(self, context, u, x, y):
        y[:] = x


if __name__ == '__main__':
    Rx = CalcRx(np.random.rand()*2*np.pi)
    Ry = CalcRy(np.random.rand()*2*np.pi)
    Rz = CalcRz(np.random.rand()*2*np.pi)
    print Rx.T.dot(Rx)
    print Ry.T.dot(Ry)
    print Rz.T.dot(Rz)

    x_u = np.zeros(m+n)

    system = Quadrotor()
    x_u[-4:] = system.mass * system.g /4
    partials = jacobian(system.f, x_u)
    print partials

    











